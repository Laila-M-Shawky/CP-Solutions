/* ▄█▀██▄  ▄████▄     ██╗      █████╗ ██╗██╗      █████╗      ▄█▀██▄  ▄████▄▐█░████████████▌    ██║     ██╔══██╗██║██║     ██╔══██╗    ▐█░████████████▌ ██▒███████████     ██║     ███████║██║██║     ███████║     ██▒███████████  ▀██████████▀      ██║     ██╔══██║██║██║     ██╔══██║      ▀██████████▀     ▀████▀         ███████╗██║  ██║██║███████╗██║  ██║         ▀████▀       ▀▀           ╚══════╝╚═╝  ╚═╝╚═╝╚══════╝╚═╝  ╚═╝           ▀▀Believe in yourself ,( try and try and then try ), You can do it =D ⡿⣡⣿⣿⡟⡼⡁⠁⣰⠂⡾⠉⢨⣿⠃⣿⡿⠍⣾⣟⢤⣿⢇⣿⢇⣿⣿⢿⣱⣿⣿⡟⡐⣰⣧⡷⣿⣴⣧⣤⣼⣯⢸⡿⠁⣰⠟⢀⣼⠏⣲⠏⢸⣿⡟⣿⣿⣿⡟⠁⠄⠟⣁⠄⢡⣿⣿⣿⣿⣿⣿⣦⣼⢟⢀⡼⠃⡹⠃⡀⢸⡿⢸⣿⣿⣿⠃⠄⢀⣾⠋⠓⢰⣿⣿⣿⣿⣿⣿⠿⣿⣿⣾⣅⢔⣕⡇⡇⡼⢁⣿⣿⣿⡟⠄⠄⣾⣇⠷⣢⣿⣿⣿⣿⣿⣿⣿⣭⣀⡈⠙⢿⣿⣿⡇⡧⢁⣾⣿⣿⣿⡇⠄⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⢻⠇⠄⠄⢿⣿⡇⢡⣾⣿⣿⣿⣿⣷⢰⣿⣿⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⢰⣧⣀⡄⢀⠘⡿⣰⣿⣿⣿⣿⣿⢹⣿⢸⣿⣿⠟⠻⢿⣿⣿⣿⣿⣿⣿⣿⣶⣭⣉⣤⣿⢈⣼⣿⣿⣿⣿⣿⣿⢸⠇⡜⣿⡟⠄⠄⠄⠈⠙⣿⣿⣿⣿⣿⣿⣿⣿⠟⣱⣻⣿⣿⣿⣿⣿⠟⠁⠄⣰⡗⠹⣿⣄⠄⠄⠄⢀⣿⣿⣿⣿⣿⣿⠟⣅⣥⣿⣿⣿⣿⠿⠋⠄⠄⣾⠜⠋⢠⣷⢻⣿⣿⣶⣾⣿⣿⣿⣿⠿⣛⣥⣾⣿⠿⠟⠛⠉⠄⠄   */ #include <bits/stdc++.h>#include <unordered_map>#define endl "\n"#define ceil(x, y) ((x + y - 1) / y)#define floor(x, y) (x / y)#define round(x, y) ((x + y / 2) / y)#define clr(arr, x) memset(arr, x, sizeof arr)#define all(v) v.begin(), v.end()#define allr(s) s.rbegin(), s.rend()#define rt(s) return cout << s, 0#define duplicateremove(v) v.erase(unique(v.begin(), v.end()), v.end()) // ٌRemoves only consecutive duplicates#define watch(x) cout << (#x) << " = " << x << endl#define sz(s) (int)(s.size())#define OO 0x3f3f3f3f3f3f3f3fLLconst int oo = 0x3f3f3f3f, mod = 1e9 + 7;using namespace std;typedef long long ll;typedef long double ld;typedef unsigned long long ull;int dx[]{1, -1, 0, 0, 1, 1, -1, -1};int dy[]{0, 0, 1, -1, 1, -1, 1, -1};void Statixia(){    // #ifndef ONLINE_JUDGE    // freopen("input.txt", "r", stdin);    // freopen("output.txt", "w", stdout);    // #endif    ios::sync_with_stdio(0);    cin.tie(0);    cout.tie(0);}ll gcd(ll a, ll b){    return b == 0 ? abs(a) : gcd(b, a % b);}ll lcm(ll a, ll b){    return a / gcd(a, b) * b;} // write your constraints here// todo Constraints:// todo t  1≤t≤104// todo p  1≤|p|≤2⋅105// todo  s 1≤|p|≤|s|≤2⋅105 ll countConsequetiveDuplicates(string & s, ll indx){    ll counter = 1;    for (ll i = indx + 1; i < s.size(); ++i)    {        if(s[i] == s[indx])            counter++;        else            break;    }    return counter;} string solve(){    ll index_s = 0, index_t = 0, counDupS = 0, counDupT = 0;    string s, t;    cin >> s >> t;    // if(t.size() > s.size() * 2)    // return "NO";    // string s_copy = s, t_copy = t;    // duplicateremove(s_copy);    // duplicateremove(t_copy);    // if (s_copy != t_copy)    // {    //     return "NO";    // }    // if ((ll)t.size() < (ll)s.size() || (ll)t.size() > 2LL * (ll)s.size())    // return "NO";    while(index_t < t.size() && index_s < s.size())    {        counDupS = countConsequetiveDuplicates(s, index_s);        counDupT = countConsequetiveDuplicates(t, index_t);        //cout << index_s << ' ' << index_t << ' ';        if((s[index_s] == t[index_t]) && (counDupT <= counDupS * 2) && ((counDupT >= counDupS)))        {            index_s += counDupS;            index_t += counDupT;        }        else        {            return "NO";        }        //cout << index_s << ' ' << index_t << endl;    }    if(index_s ==  s.size() && index_t == t.size())        return "YES";    else        return "NO";    // string s, t, s_updated, t_updated, s_copy, t_copy;    // ll counter = 1, shifts = 0;    // cin >> s >> t;    // s_copy = s, t_copy = t;    // duplicateremove(s_copy);    // duplicateremove(t_copy);    // if (s_copy != t_copy)    // {    //     return "NO";    // }    // for(ll i = 0; i < s.size(); ++i)    // {    //     if(s[i] != t[i + shifts])    //     {    //         if(s[i] == t[i + shifts + 1])    //             shifts++;    //         else    //             return "NO";    //     }    // }    // for (int i = 0; i < s.size() - 1; ++i)    // {    //     s_updated.push_back(s[i]);    //     if(s[i] == s[i + 1])    //     {    //         ++i;    //     }    // }    // for (int i = s.size() - 2; i >= 0; --i)    // {    //     if(s[i] == s[s.size() - 1])    //     {    //         ++counter;    //     }    //     else    //     {    //         break;    //     }    // }    // if(counter & 1) s_updated.push_back(s[s.size() - 1]);    // counter = 1;    // for (int i = 0; i < t.size() - 1; ++i)    // {    //     t_updated.push_back(t[i]);    //     if(t[i] == t[i + 1])    //     {    //         ++i;    //     }    // }    // for (int i = t.size() - 2; i >= 0; --i)    // {    //     if(t[i] == t[t.size() - 1])    //     {    //         ++counter;    //     }    //     else    //     {    //         break;    //     }    // }    // if(counter & 1) t_updated.push_back(t[t.size() - 1]);    // return (s_updated == t_updated || s_updated == t || s == t_updated || t == s)? "YES" : "NO";} int main(){    Statixia();    int t = 1;    cin >> t;    while (t--)    {        cout << solve() << endl;    }    return 0;}